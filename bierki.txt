# 1000 8 białe                          # 10000 16 czarne

# 001 1 Pionek-                         # 010 2 Pionek+
# 011 3 król                            # 011 3 król
# 100 4 koń                             # 100 4 koń
# 101 5 goniec                          # 101 5 goniec
# 110 6 wieża                           # 110 6 wieża
# 111 7 hetman                          # 111 7 hetman

# 1000 | 001 = 1001 9  biały Pionek     # 10000 | 001 = 10001 18 czarny Pionek
# 1000 | 011 = 1011 11 biały król       # 10000 | 011 = 10011 19 czarny król
# 1000 | 100 = 1100 12 biały koń        # 10000 | 100 = 10100 20 czarny koń
# 1000 | 101 = 1101 13 biały goniec     # 10000 | 101 = 10101 21 czarny goniec
# 1000 | 110 = 1110 14 biała wieża      # 10000 | 110 = 10110 22 czarna wieża
# 1000 | 111 = 1111 15 biały hetman     # 10000 | 111 = 10111 23 czarny hetman





int Plansza[128] = {                

    22, 20, 21, 23, 19, 21, 20, 22,     0, 0, 0, 0, 0, 0, 0, 0,
    18, 18, 18, 18, 18, 18, 18, 18,     0, 0, 0, 0, 0, 0, 0, 0,
     0,  0,  0,  0,  0,  0,  0,  0,     0, 0, 0, 0, 0, 0, 0, 0,
     0,  0,  0,  0,  0,  0,  0,  0,     0, 0, 0, 0, 0, 0, 0, 0,
     0,  0,  0,  0,  0,  0,  0,  0,     0, 0, 0, 0, 0, 0, 0, 0,
     0,  0,  0,  0,  0,  0,  0,  0,     0, 0, 0, 0, 0, 0, 0, 0,
     9,  9,  9,  9,  9,  9,  9,  9,     0, 0, 0, 0, 0, 0, 0, 0,
    14, 12, 13, 15, 11, 13, 12, 14,     0, 0, 0, 0, 0, 0, 0, 0,

};

To do:
    1. Roszada
    2. en passant
    3. negamax
    4. (opcjonalnie) plansza ladna

    // int NegaMax(szachownica *sz_nm, int glebokosc_nm, int alpha_nm, int beta_nm, int strona_nm){
//     int maxEval, minEval, eval;
//     int ocena_nm;
//     ocena_nm = OcenaGry(sz_nm);
//     if((glebokosc_nm == 0) || ocena_nm != 0){
//         return ZliczanieBierkek(sz_nm);
//     }
//     if(strona_nm == 8){
//         maxEval = -10000
//         while()
//     }
//     else{

//     }
// }

// int negaMax(szachownica * sz_nm, int glebokosc_nm, int alfa_nm, int beta_nm)
// {
// if (!glebokosc_nm){
//     return ZliczanieBierkek(*sz_nm);
// }

//     int nowaocena_nm;
//     int ocenawezla_nm=-2000;
//     int i=0;
// for(ruchy *glowa_lr = ZrobListeRuchow(*sz_nm), *ptr = lr; lr; i++, lr = lr->next, free(ptr), ptr = lr)
// {
//     Plansza dziecko = wykonaj_ruch(*sz, ptr->kolumna); //plansza po ruchu to dziecko
//     nowaocena = -negmax(&dziecko, glebokosc - 1, -beta, -alfa);
//     // printf("iteracja:%d\n",i);
//     // printf("nowaocena1:%d\n",nowaocena);
//     // printf("ocenawezla1:%d\n",ocenawezla);
//     if (nowaocena > ocenawezla)
//     ocenawezla = nowaocena;
//     if (ocenawezla > alfa)
//     alfa = ocenawezla;
//     // printf("alfa:%d\n\n",alfa);
//     if (alfa > beta)
//     {
//         // zwolninenie listy ruchów do końca
//         break;
//     }
// }
//     return ocenawezla;
// }